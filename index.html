<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fliplish Translator</title>

  <style>
    :root {
      --bg: #d8cbb8;                 /* night-light taupe */
      --panel: rgba(255,255,255,0.78);
      --border: rgba(17, 24, 39, 0.18);
      --text: #111827;
    }

    * { box-sizing: border-box; }
    html, body { overflow-x: hidden; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      margin: 24px;
      line-height: 1.35;
      background: var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      outline: none;
    }

    textarea:focus { border-color: rgba(17, 24, 39, 0.35); }

    .row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select {
      padding: 10px 12px;
      font-size: 15px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.65);
      color: var(--text);
      cursor: pointer;
    }

    button:active { transform: translateY(1px); }

    .hint { opacity: 0.75; font-size: 13px; margin-top: 8px; }
  </style>
</head>

<body>
  <div class="container">
    <h1>Fliplish Translator</h1>

    <label for="input">Input</label>
    <textarea id="input" placeholder="Type English (or coded text) here..."></textarea>

    <div class="row">
      <button id="encode">Encode ‚Üí</button>
      <button id="decode">‚Üê Decode</button>
      <button id="clear">Clear</button>

      <label>
        Suffix mode:
        <select id="suffixMode">
          <option value="single" selected>Single</option>
          <option value="aeo">AEO Rotate</option>
          <option value="random">Random</option>
        </select>
      </label>

      <label>
        Suffix:
        <select id="suffix"></select>
      </label>

      <label>
        Move letters:
        <select id="moveN">
          <option value="1" selected>1</option>
          <option value="2">2</option>
        </select>
      </label>

      <label>
        Preserve capitalization:
        <select id="caps">
          <option value="yes">Yes</option>
          <option value="no" selected>No</option>
        </select>
      </label>
    </div>

    <label for="output">Output</label>
    <textarea id="output" readonly></textarea>

    <div class="hint">
      Rule: move first letter(s) to end + add suffix (encode). Remove suffix + move last letter(s) to front (decode).
      AEO Rotate counts only word tokens (punctuation doesn‚Äôt affect the cycle). Apostrophes inside words are preserved. üôÇ
    </div>

<script>
  const inputEl = document.getElementById("input");
  const outputEl = document.getElementById("output");
  const suffixEl = document.getElementById("suffix");
  const suffixModeEl = document.getElementById("suffixMode");
  const moveNEl = document.getElementById("moveN");
  const capsEl = document.getElementById("caps");
  const clearBtn = document.getElementById("clear");

  const LETTERS = "abcdefghijklmnopqrstuvwxyz";

  // Populate suffix dropdown with a‚Äìz (default = a)
  (function initSuffixOptions() {
    const defaultSuffix = "a";
    suffixEl.innerHTML = "";
    for (const ch of LETTERS) {
      const opt = document.createElement("option");
      opt.value = ch;
      opt.textContent = ch;
      if (ch === defaultSuffix) opt.selected = true;
      suffixEl.appendChild(opt);
    }
  })();

  // Disable manual suffix picker when in AEO or Random mode
  function syncSuffixUI() {
    const mode = suffixModeEl.value;
    const disabled = (mode === "aeo" || mode === "random");
    suffixEl.disabled = disabled;
    suffixEl.style.opacity = disabled ? "0.55" : "1";
  }
  suffixModeEl.addEventListener("change", syncSuffixUI);
  syncSuffixUI();

  // Tokenizer: keeps internal apostrophes together (supports ' and ‚Äô)
  function tokenize(text) {
    return text.match(/[A-Za-z]+(?:['‚Äô][A-Za-z]+)*|[^A-Za-z]+/g) || [];
  }

  function detectCapsStyle(word) {
    if (word.toUpperCase() === word) return "upper";
    if (word[0].toUpperCase() === word[0] &&
        word.slice(1).toLowerCase() === word.slice(1)) return "title";
    return "lower";
  }

  function encodeWord(word, suffix, preserveCaps, moveN) {
    const style = preserveCaps ? detectCapsStyle(word) : "lower";
    const w = word.toLowerCase();
    if (w.length < 1) return word;

    const n = Math.min(moveN, w.length);
    const head = w.slice(0, n);
    const rest = w.slice(n);
    let coded = rest + head + suffix;

    if (!preserveCaps) return coded;

    if (style === "upper") return coded.toUpperCase();

    if (style === "title") {
      const idx = rest.length; // where original first letter ended up
      coded =
        coded.slice(0, idx) +
        coded[idx].toUpperCase() +
        coded.slice(idx + 1);
      return coded;
    }

    return coded;
  }

  function decodeWord(word, suffix, preserveCaps, moveN) {
    const style = preserveCaps ? detectCapsStyle(word) : "lower";
    const w = word.toLowerCase();
    if (!w.endsWith(suffix) || w.length < 2) return word;

    const core = w.slice(0, -1);
    const n = Math.min(moveN, core.length);

    const tail = core.slice(-n);
    const rest = core.slice(0, -n);
    let plain = tail + rest;

    if (!preserveCaps) return plain;

    if (style === "upper") return plain.toUpperCase();

    if (style === "title") {
      plain = plain[0].toUpperCase() + plain.slice(1);
      return plain;
    }

    return plain;
  }

  function randomSuffix() {
    return LETTERS[Math.floor(Math.random() * LETTERS.length)];
  }

  // Picks suffix per word depending on mode (ENCODE side)
  function getSuffixForWord(wordIndex) {
    const mode = suffixModeEl.value;
    if (mode === "aeo") {
      const cycle = ["a", "e", "o"];
      return cycle[wordIndex % cycle.length];
    }
    if (mode === "random") {
      return randomSuffix();
    }
    return suffixEl.value; // single
  }

  function lastCharSuffix(tok) {
    const last = tok[tok.length - 1] || "";
    const low = last.toLowerCase();
    return /[a-z]/.test(low) ? low : null;
  }

  function transform(text, mode) {
    const preserveCaps = capsEl.value === "yes";
    const moveN = parseInt(moveNEl.value, 10);
    const tokens = tokenize(text);

    let wordIndex = 0;
    const out = tokens.map(tok => {
      if (/^[A-Za-z]/.test(tok)) {
        let suffix;

        if (mode === "decode") {
          // ‚úÖ decode uses the actual suffix on the word (supports Random automatically)
          suffix = lastCharSuffix(tok) || getSuffixForWord(wordIndex);
        } else {
          suffix = getSuffixForWord(wordIndex);
        }

        const result = (mode === "encode")
          ? encodeWord(tok, suffix, preserveCaps, moveN)
          : decodeWord(tok, suffix, preserveCaps, moveN);

        wordIndex++;
        return result;
      }
      return tok;
    });

    return out.join("");
  }

  document.getElementById("encode").onclick = () =>
    outputEl.value = transform(inputEl.value, "encode");

  document.getElementById("decode").onclick = () =>
    outputEl.value = transform(inputEl.value, "decode");

  clearBtn.onclick = () => {
    inputEl.value = "";
    outputEl.value = "";
    inputEl.focus();
  };
</script>
  </div>
</body>
</html>