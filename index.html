<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fliplish Translator</title>

  <style>
    :root {
      --bg: #d8cbb8;
      --panel: rgba(255,255,255,0.78);
      --border: rgba(17, 24, 39, 0.18);
      --text: #111827;
    }

    * { box-sizing: border-box; }
    html, body { overflow-x: hidden; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      margin: 24px;
      line-height: 1.35;
      background: var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      outline: none;
    }

    .row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select, input[type="checkbox"] {
      font-size: 15px;
    }

    button, select {
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.65);
      cursor: pointer;
    }

    label.chk {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.45);
      user-select: none;
    }

    .hint { opacity: 0.75; font-size: 13px; margin-top: 8px; }
  </style>
</head>

<body>
<div class="container">
  <h1>Fliplish Translator</h1>

  <textarea id="input" placeholder="Type English (or coded text) here..."></textarea>

  <div class="row">
    <button id="encode">Encode →</button>
    <button id="decode">← Decode</button>
    <button id="clear">Clear</button>

    <label>
      Mode:
      <select id="mode">
        <option value="classic" selected>Classic</option>
        <option value="street">Street</option>
      </select>
    </label>

    <label>
      Suffix mode:
      <select id="suffixMode">
        <option value="single" selected>Single</option>
        <option value="aeo">AEO Rotate</option>
        <option value="random">Random</option>
      </select>
    </label>

    <label>
      Suffix:
      <select id="suffix"></select>
    </label>

    <label>
      Move letters:
      <select id="moveN">
        <option value="1" selected>1</option>
        <option value="2">2</option>
      </select>
    </label>

    <label>
      Preserve capitalization:
      <select id="caps">
        <option value="yes">Yes</option>
        <option value="no" selected>No</option>
      </select>
    </label>

    <label class="chk" id="smartDecodeWrap"
      title="Classic only: tries 1 vs 2 and picks the most 'English-looking' result">
      <input id="smartDecode" type="checkbox" checked />
      Smart Decode
    </label>
  </div>

  <textarea id="output" readonly></textarea>

  <div class="hint">
    How Fliplish works: Each word is encoded by moving the first one or two letters to the end of the word and then adding a suffix.
    To decode, the suffix is removed and those letters are moved back to the front, restoring the original word.
    Punctuation, spacing, and contractions (like I’m or don’t) are preserved so the text stays readable.
  </div>
</div>

<script>
/** ====== Suffixes ====== **/
const LETTERS = "abcdefghijklmnopqrstuvwxyz".split("");
const EXTRA_SUFFIXES = ["sh", "ch", "th"]; // shown first
const ALL_SUFFIXES = [...EXTRA_SUFFIXES, ...LETTERS];

/** ====== Elements ====== **/
const inputEl = document.getElementById("input");
const outputEl = document.getElementById("output");
const modeEl = document.getElementById("mode");
const suffixEl = document.getElementById("suffix");
const suffixModeEl = document.getElementById("suffixMode");
const moveNEl = document.getElementById("moveN");
const capsEl = document.getElementById("caps");
const smartDecodeEl = document.getElementById("smartDecode");
const smartDecodeWrap = document.getElementById("smartDecodeWrap");

/** ====== Init suffix dropdown (SH/CH/TH then A-Z) ====== **/
(function initSuffix() {
  suffixEl.innerHTML = "";
  for (const s of ALL_SUFFIXES) {
    const o = document.createElement("option");
    o.value = s;
    o.textContent = s.toUpperCase();
    if (s === "a") o.selected = true;
    suffixEl.appendChild(o);
  }
})();

/** Disable manual suffix picker in AEO/Random mode */
function syncSuffixUI() {
  const mode = suffixModeEl.value;
  const disabled = (mode === "aeo" || mode === "random");
  suffixEl.disabled = disabled;
  suffixEl.style.opacity = disabled ? "0.55" : "1";
}
suffixModeEl.addEventListener("change", syncSuffixUI);
syncSuffixUI();

/** Street Mode: disable Smart Decode (it’s English-biased scoring) */
function syncModeUI() {
  const street = (modeEl.value === "street");
  smartDecodeEl.disabled = street;
  smartDecodeWrap.style.opacity = street ? "0.55" : "1";
  smartDecodeWrap.title = street
    ? "Street Mode: Smart Decode disabled (Classic-only English scoring)"
    : "Classic only: tries 1 vs 2 and picks the most 'English-looking' result";
  if (street) smartDecodeEl.checked = false;
}
modeEl.addEventListener("change", syncModeUI);
syncModeUI();

/** ====== Tokenizers ====== **/
/** Classic: preserves punctuation as separate tokens */
function tokenizeClassic(text) {
  return text.match(/[A-Za-z]+(?:['’][A-Za-z]+)*|[^A-Za-z]+/g) || [];
}
/** Street: split ONLY by spaces (keeps emojis/diacritics/punct inside chunks) */
function tokenizeStreet(text) {
  // Keep whitespace tokens so spacing is perfectly preserved
  return text.split(/(\s+)/);
}

function detectCapsStyle(word) {
  if (word === word.toUpperCase()) return "upper";
  if (word[0] === word[0].toUpperCase() && word.slice(1) === word.slice(1).toLowerCase()) return "title";
  return "lower";
}

/** ====== Apostrophe-safe helpers (Classic words) ====== **/
function splitApostrophes(word) {
  const letters = [];
  const apos = [];
  [...word].forEach((c, i) => {
    if (c === "'" || c === "’") apos.push({ i, c });
    else letters.push(c);
  });
  return { letters: letters.join(""), apos };
}
function restoreApostrophes(word, apos) {
  const arr = [...word];
  apos.forEach(({ i, c }) => {
    const idx = Math.max(0, Math.min(i, arr.length));
    arr.splice(idx, 0, c);
  });
  return arr.join("");
}

/** ====== Classic encode/decode (letters only) ====== **/
function encodeWordClassic(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();
  const { letters, apos } = splitApostrophes(lower);
  if (!letters) return word;

  const n = Math.min(moveN, letters.length);
  let codedLetters = letters.slice(n) + letters.slice(0, n) + suffix;
  let coded = restoreApostrophes(codedLetters, apos);

  if (!preserveCaps) return coded;
  if (style === "upper") return coded.toUpperCase();
  if (style === "title") return coded[0].toUpperCase() + coded.slice(1);
  return coded;
}

function decodeWordClassic(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();
  if (!lower.endsWith(suffix)) return word;

  const core = lower.slice(0, -suffix.length);
  const { letters, apos } = splitApostrophes(core);
  if (!letters) return word;

  const n = Math.min(moveN, letters.length);
  let plainLetters = letters.slice(-n) + letters.slice(0, -n);
  let plain = restoreApostrophes(plainLetters, apos);

  if (!preserveCaps) return plain;
  if (style === "upper") return plain.toUpperCase();
  if (style === "title") return plain[0].toUpperCase() + plain.slice(1);
  return plain;
}

/** ====== Street encode/decode (raw characters, any language) ====== **/
function encodeChunkStreet(chunk, suffix, moveN) {
  const arr = [...chunk]; // handles unicode safely
  if (arr.length === 0) return chunk;
  const n = Math.min(moveN, arr.length);
  return arr.slice(n).join("") + arr.slice(0, n).join("") + suffix;
}
function decodeChunkStreet(chunk, suffix, moveN) {
  if (!chunk.toLowerCase().endsWith(suffix)) return chunk;
  const core = chunk.slice(0, -suffix.length);
  const arr = [...core];
  if (arr.length === 0) return chunk;
  const n = Math.min(moveN, arr.length);
  return arr.slice(-n).join("") + arr.slice(0, -n).join("");
}

/** ====== Suffix selection ====== **/
function randomSuffix() {
  return ALL_SUFFIXES[Math.floor(Math.random() * ALL_SUFFIXES.length)];
}
function getSuffixForWord(i) {
  const mode = suffixModeEl.value;
  if (mode === "aeo") return ["a","e","o"][i % 3];
  if (mode === "random") return randomSuffix();
  return suffixEl.value; // single
}
/** Pull suffix from a token (supports 2-letter suffixes SH/CH/TH) */
function suffixFromToken(tok) {
  const low = tok.toLowerCase();
  for (const s of EXTRA_SUFFIXES) {
    if (low.endsWith(s)) return s;
  }
  const last = low[low.length - 1] || "";
  return /[a-z]/.test(last) ? last : null;
}

/** ====== Smart Decode (Classic only) ====== **/
const COMMON = new Set([
  "the","a","an","and","or","but","is","are","was","were","be","been","being",
  "i","you","he","she","it","we","they","me","him","her","us","them",
  "my","your","his","hers","our","their",
  "to","of","in","on","at","for","from","with","as","by",
  "this","that","these","those","not","no","yes",
  "table","carpet","front","house","road","store","tomorrow","today","now","then",
  "test","program"
]);
const COMMON_TRI = ["the","and","pro","con","int","for","tha","thi","wit","you","not","are","was"];

function scorePlainWord(w) {
  const low = w.toLowerCase();
  const lettersOnly = low.replace(/[^a-z]/g, "");
  if (lettersOnly.length === 0) return -999;

  let score = 0;
  if (COMMON.has(lettersOnly)) score += 8;

  const vowels = (lettersOnly.match(/[aeiouy]/g) || []).length;
  score += vowels * 2;

  if (/[^aeiouy]{5,}/.test(lettersOnly)) score -= 7;
  if (/[jqxz]{2,}/.test(lettersOnly)) score -= 6;
  if (/(.)\1\1/.test(lettersOnly)) score -= 3;

  if (/(ing|ed|ly|tion|s)$/.test(lettersOnly)) score += 2;

  if (low.includes("'") || low.includes("’")) {
    if (/^['’]/.test(low)) score -= 10;
    if (/[a-z]['’][a-z]/.test(low)) score += 2;
  }
  return score;
}

function smartDecodeTokenClassic(tok, preserveCaps) {
  const sfx = suffixFromToken(tok);
  if (!sfx) return tok;

  const cand1 = decodeWordClassic(tok, sfx, preserveCaps, 1);
  const cand2 = decodeWordClassic(tok, sfx, preserveCaps, 2);

  const sc1 = scorePlainWord(cand1);
  const sc2 = scorePlainWord(cand2);

  if (sc2 > sc1 + 1) return cand2;
  if (sc1 > sc2 + 1) return cand1;

  const a = cand1.toLowerCase().replace(/[^a-z'’]/g, "");
  const b = cand2.toLowerCase().replace(/[^a-z'’]/g, "");

  const aClean = a.replace(/['’]/g, "");
  const bClean = b.replace(/['’]/g, "");

  if (COMMON.has(bClean) && !COMMON.has(aClean)) return cand2;
  if (COMMON.has(aClean) && !COMMON.has(bClean)) return cand1;

  const a3 = aClean.slice(0,3);
  const b3 = bClean.slice(0,3);
  if (COMMON_TRI.includes(b3) && !COMMON_TRI.includes(a3)) return cand2;
  if (COMMON_TRI.includes(a3) && !COMMON_TRI.includes(b3)) return cand1;

  // default to move=2 when tied
  return cand2;
}

/** ====== Transform ====== **/
function transform(text, mode) {
  const preserveCaps = capsEl.value === "yes";
  const moveN = +moveNEl.value;
  const street = (modeEl.value === "street");

  const tokens = street ? tokenizeStreet(text) : tokenizeClassic(text);
  let wordIndex = 0;

  return tokens.map(tok => {
    // Preserve whitespace exactly (street tokenizer keeps it)
    if (street && /^\s+$/.test(tok)) return tok;

    if (mode === "encode") {
      const suffix = getSuffixForWord(wordIndex);
      wordIndex++;

      if (street) {
        return encodeChunkStreet(tok, suffix, moveN);
      } else {
        // only encode word-ish tokens in classic
        if (/^[A-Za-z]/.test(tok)) return encodeWordClassic(tok, suffix, preserveCaps, moveN);
        return tok;
      }
    }

    // DECODE
    if (street) {
      // Street decode is mechanical. Use suffix in token if present; fallback to UI.
      const sfx = suffixFromToken(tok) || getSuffixForWord(wordIndex);
      wordIndex++;
      return decodeChunkStreet(tok, sfx, moveN);
    } else {
      if (/^[A-Za-z]/.test(tok)) {
        const useSmart = !!smartDecodeEl?.checked;
        wordIndex++;
        if (useSmart) return smartDecodeTokenClassic(tok, preserveCaps);

        const sfx = suffixFromToken(tok) || getSuffixForWord(wordIndex - 1);
        return decodeWordClassic(tok, sfx, preserveCaps, moveN);
      }
      return tok;
    }
  }).join("");
}

/** ====== Buttons ====== **/
document.getElementById("encode").onclick = () =>
  outputEl.value = transform(inputEl.value, "encode");

document.getElementById("decode").onclick = () =>
  outputEl.value = transform(inputEl.value, "decode");

document.getElementById("clear").onclick = () => {
  inputEl.value = "";
  outputEl.value = "";
  inputEl.focus();
};
</script>
</body>
</html>